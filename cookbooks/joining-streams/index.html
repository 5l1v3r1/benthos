<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../img/favicon.ico">
        <title>Joining streams - Benthos</title>
        <link href="../../css/bootstrap-custom.min.css" rel="stylesheet">
        <link href="../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css">
        <!-- HTML5 shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->

        <script src="../../js/jquery-1.10.2.min.js" defer></script>
        <script src="../../js/bootstrap-3.0.3.min.js" defer></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/languages/yaml.min.js"></script>
        <script>hljs.initHighlightingOnLoad();</script> 
    </head>

    <body>

        <div class="navbar navbar-default navbar-fixed-top" role="navigation">
            <div class="container">

                <!-- Collapsed navigation -->
                <div class="navbar-header">
                    <!-- Expander button -->
                    <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
                        <span class="sr-only">Toggle navigation</span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                        <span class="icon-bar"></span>
                    </button>
                    <a class="navbar-brand" href="../">Benthos</a>
                </div>

                <!-- Expanded navigation -->
                <div class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li >
                                <a href="/">Home</a>
                            </li>
                            <li >
                                <a href="../">Cookbooks</a>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Components <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../inputs/">Inputs</a>
</li>
                                    
<li >
    <a href="../../buffers/">Buffers</a>
</li>
                                    
<li >
    <a href="../../processors/">Processors</a>
</li>
                                    
<li >
    <a href="../../conditions/">Conditions</a>
</li>
                                    
<li >
    <a href="../../outputs/">Outputs</a>
</li>
                                    
<li >
    <a href="../../caches/">Caches</a>
</li>
                                    
<li >
    <a href="../../rate_limits/">Rate Limits</a>
</li>
                                    
<li >
    <a href="../../metrics/">Metrics</a>
</li>
                                    
<li >
    <a href="../../tracers/">Tracers</a>
</li>
                                </ul>
                            </li>
                            <li class="dropdown">
                                <a href="#" class="dropdown-toggle" data-toggle="dropdown">Guides <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li >
    <a href="../../getting_started/">Getting Started</a>
</li>
                                    
<li >
    <a href="../../serverless/">Serverless</a>
</li>
                                    
<li >
    <a href="../../pipeline/">Processing Pipelines</a>
</li>
                                    
<li >
    <a href="../../batching/">Message Batching</a>
</li>
                                    
<li >
    <a href="../../error_handling/">Error Handling</a>
</li>
                                    
<li >
    <a href="../../workflows/">Workflows</a>
</li>
                                    
<li >
    <a href="../../configuration/">Config Cheats</a>
</li>
                                    
<li >
    <a href="../../config_interpolation/">Config Interpolation</a>
</li>
                                    
<li >
    <a href="../../examples/">Applied Examples</a>
</li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav navbar-right">
                        <li>
                            <a href="#" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
                <div class="col-md-3"><div class="bs-sidebar hidden-print affix well" role="complementary">
    <ul class="nav bs-sidenav">
        <li class="main active"><a href="#joining-streams">Joining Streams</a></li>
            <li><a href="#caching-articles">Caching Articles</a></li>
            <li><a href="#hydrating-comments">Hydrating Comments</a></li>
            <li><a href="#adding-a-retry-queue">Adding a Retry Queue</a></li>
    </ul>
</div></div>
                <div class="col-md-9" role="main">

<h1 id="joining-streams">Joining Streams</h1>
<p>This cookbook demonstrates how to merge JSON events from parallel streams
using content based rules and a cache of your choice.</p>
<p>The imaginary problem we are going to solve is hydrating a feed of article
comments with information from their parent articles. We will be consuming and
writing to Kafka, but the example works with any <a href="../../inputs/">input</a> and
<a href="../../outputs/">output</a> combination.</p>
<p>Articles are received over the topic <code>articles</code> and look like this:</p>
<pre><code class="json">{
  &quot;type&quot;: &quot;article&quot;,
  &quot;article&quot;: {
    &quot;id&quot;: &quot;123foo&quot;,
    &quot;title&quot;: &quot;Dope article&quot;,
    &quot;content&quot;: &quot;this is a totally dope article&quot;
  },
  &quot;user&quot;: {
    &quot;id&quot;: &quot;user1&quot;
  }
}
</code></pre>

<p>Comments can either be posted on an article or a parent comment, are received
over the topic <code>comments</code>, and look like this:</p>
<pre><code class="json">{
  &quot;type&quot;: &quot;comment&quot;,
  &quot;comment&quot;: {
    &quot;id&quot;: &quot;456bar&quot;,
    &quot;parent_id&quot;: &quot;123foo&quot;,
    &quot;content&quot;: &quot;this article sucks&quot;
  },
  &quot;user&quot;: {
    &quot;id&quot;: &quot;user2&quot;
  }
}
</code></pre>

<p>Our goal is to end up with a single stream of comments, where information about
the root article of the comment is attached to the event. The above comment
should exit our pipeline looking like this:</p>
<pre><code class="json">{
  &quot;type&quot;: &quot;comment&quot;,
  &quot;comment&quot;: {
    &quot;id&quot;: &quot;456bar&quot;,
    &quot;parent_id&quot;: &quot;123foo&quot;,
    &quot;content&quot;: &quot;this article sucks&quot;
  },
  &quot;article&quot;: {
    &quot;title&quot;: &quot;Dope article&quot;,
    &quot;content&quot;: &quot;this is a totally dope article&quot;
  },
  &quot;user&quot;: {
    &quot;id&quot;: &quot;user2&quot;
  }
}
</code></pre>

<p>In order to achieve this we will need to cache articles as they pass through our
pipelines and then retrieve them for each comment passing through. Since the
parent of a comment might be another comment we will also need to cache and
retrieve comments in the same way.</p>
<h2 id="caching-articles">Caching Articles</h2>
<p>Our first pipeline is very simple, we just consume articles, reduce them to only
the fields we wish to cache, and then cache them. If we receive the same article
multiple times we're going to assume it's okay to overwrite the old article in
the cache.</p>
<p>In this example I'm targeting Redis, but you can choose any of the supported
<a href="../../caches/">cache targets</a>. The TTL of cached articles is set to one week.</p>
<pre><code class="yaml">input:
  type: kafka_balanced
  kafka_balanced:
    addresses:
    - TODO
    topics:
    - articles
    consumer_group: benthos_articles_group

pipeline:
  processors:
  # Reduce document into only fields we wish to cache.
  - type: jmespath
    jmespath:
      query: '{&quot;article&quot;: article}'

  # Store reduced articles into our cache.
  - type: cache
    cache:
      operator: set
      cache: hydration_cache
      key: &quot;${!json_field:article.id}&quot;
      value: &quot;${!content}&quot;

# Drop all articles after they are cached.
output:
  type: drop

resources:
  caches:
    hydration_cache:
      type: redis
      redis:
        expiration: 168h
        retries: 3
        retry_period: 500ms
        url: TODO
</code></pre>

<h2 id="hydrating-comments">Hydrating Comments</h2>
<p>Our second pipeline consumes comments, caches them in case a subsequent comment
references them, obtains its parent (article or comment), and attaches the root
article to the event before sending it to our output topic <code>comments_hydrated</code>.</p>
<p>In this config we make use of the <a href="../../processors/#process_map"><code>process_map</code></a> processor as it
allows us to reduce documents into smaller maps for caching and gives us greater
control over how results are mapped back into the document.</p>
<pre><code class="yaml">input:
  type: kafka_balanced
  kafka_balanced:
    addresses:
    - TODO
    topics:
    - comments
    consumer_group: benthos_comments_group

pipeline:
  processors:
  # Attempt to obtain parent event from cache.
  - type: process_map
    process_map:
      premap:
        parent_id: comment.parent_id
      processors:
      - type: cache
        cache:
          operator: get
          cache: hydration_cache
          key: &quot;${!json_field:parent_id}&quot;
      postmap:
        # We only need the article section of our parent document.
        article: article

  # Reduce comment into only fields we wish to cache.
  - type: process_map
    process_map:
      premap:
        comment.id: comment.id
        article: article
      processors:
      # Store reduced comment into our cache.
      - type: cache
        cache:
          operator: set
          cache: hydration_cache
          key: &quot;${!json_field:comment.id}&quot;
          value: &quot;${!content}&quot;
      postmap_optional:
        # Dummy map since we don't need to map the result back.
        foo: will.never.exist

# Sent resulting documents to our hydrated topic.
output:
  type: kafka
  kafka:
    addresses:
    - TODO
    topic: comments_hydrated

resources:
  caches:
    hydration_cache:
      type: redis
      redis:
        expiration: 168h
        retries: 3
        retry_period: 500ms
        url: TODO
</code></pre>

<p>This pipeline satisfies our basic needs but errors aren't handled at all,
meaning intermittent cache connectivity problems that span beyond our cache
retries will result in failed documents entering our <code>comments_hydrated</code> topic.
This is also the case if a comment arrives in our pipeline before its parent.</p>
<p>There are <a href="../../error_handling/">many patterns for error handling</a> to choose from in
Benthos. In this example we're going to introduce a delayed retry queue as it
enables us to reprocess failed documents after a grace period, which is isolated
from our main pipeline.</p>
<h2 id="adding-a-retry-queue">Adding a Retry Queue</h2>
<p>Our retry queue is going to be another topic called <code>comments_retried</code>. Since
most errors are related to time we will delay retry attempts by storing the
current timestamp after a failed request as a metadata field.</p>
<p>We will use an input <a href="../../inputs/#broker"><code>broker</code></a> so that we can consume both the
<code>comments</code> and <code>comments_retry</code> topics in the same pipeline.</p>
<p>Our config (omitting the caching sections for brevity) now looks like this:</p>
<pre><code class="yaml">input:
  type: broker
  broker:
    inputs:
    - type: kafka_balanced
      kafka_balanced:
        addresses:
        - TODO
        topics:
        - comments
        consumer_group: benthos_comments_group

    - type: kafka_balanced
      kafka_balanced:
        addresses:
        - TODO
        topics:
        - comments_retry
        consumer_group: benthos_comments_group

      processors:
      # Calcuate time until next retry attempt and sleep for that duration.
      - type: process_batch
        process_batch:
        - type: awk
          awk:
            program: |
             {
               delay_for = 3600 - (timestamp_unix() - metadata_get(&quot;last_attempted&quot;));
               if ( delay_for &lt; 0 )
                 delay_for = 0;
               metadata_set(&quot;delay_for_s&quot;, delay_for);
             }
        - type: sleep
          sleep:
            duration: &quot;${!metadata:delay_for_s}s&quot;

pipeline:
  processors:
  - type: try
    try:
    # Attempt to obtain parent event from cache.
    - type: process_map
      process_map:
        {} # Omitted

    # Reduce document into only fields we wish to cache.
    - type: process_map
      process_map:
        {} # Omitted

    # If we've reached this point then both processors succeeded.
    - type: metadata
      metadata:
        operator: set
        key: output_topic
        value: comments_hydrated

  - type: catch
    catch:
    # If we reach here then a processing stage failed.
    - type: metadata
      metadata:
        operator: set
        key: output_topic
        value: comments_retry

    # Add current timestamp.
    - type: metadata
      metadata:
        operator: set
        key: last_attempted
        value: ${!timestamp_unix}

# Sent resulting documents either to our hydrated topic or the retry topic.
output:
  type: kafka
  kafka:
    addresses:
    - TODO
    topic: ${!metadata:output_topic}

resources:
  caches:
    hydration_cache:
      {} # Omitted
</code></pre></div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script>
            var base_url = "../..",
                shortcuts = {"search": 83, "next": 78, "help": 191, "previous": 80};
        </script>
        <script src="../../js/base.js" defer></script>
        <script src="../../search/main.js" defer></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="Search Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Search</h4>
            </div>
            <div class="modal-body">
                <p>
                    From here you can search these documents. Enter
                    your search terms below.
                </p>
                <form role="form">
                    <div class="form-group">
                        <input type="text" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="Keyboard Shortcuts Modal" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
                <h4 class="modal-title" id="exampleModalLabel">Keyboard Shortcuts</h4>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
